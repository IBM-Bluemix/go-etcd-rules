
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM-Bluemix/go-etcd-rules/rules/atomic.go (100.0%)</option>
				
				<option value="file1">github.com/IBM-Bluemix/go-etcd-rules/rules/crawler.go (71.4%)</option>
				
				<option value="file2">github.com/IBM-Bluemix/go-etcd-rules/rules/dynamic_rule.go (96.4%)</option>
				
				<option value="file3">github.com/IBM-Bluemix/go-etcd-rules/rules/engine.go (94.3%)</option>
				
				<option value="file4">github.com/IBM-Bluemix/go-etcd-rules/rules/etcd.go (97.1%)</option>
				
				<option value="file5">github.com/IBM-Bluemix/go-etcd-rules/rules/int_crawler.go (73.8%)</option>
				
				<option value="file6">github.com/IBM-Bluemix/go-etcd-rules/rules/key_processor.go (75.0%)</option>
				
				<option value="file7">github.com/IBM-Bluemix/go-etcd-rules/rules/lazy_client.go (86.8%)</option>
				
				<option value="file8">github.com/IBM-Bluemix/go-etcd-rules/rules/lock.go (95.0%)</option>
				
				<option value="file9">github.com/IBM-Bluemix/go-etcd-rules/rules/matcher.go (100.0%)</option>
				
				<option value="file10">github.com/IBM-Bluemix/go-etcd-rules/rules/metrics.go (100.0%)</option>
				
				<option value="file11">github.com/IBM-Bluemix/go-etcd-rules/rules/options.go (100.0%)</option>
				
				<option value="file12">github.com/IBM-Bluemix/go-etcd-rules/rules/rule_manager.go (100.0%)</option>
				
				<option value="file13">github.com/IBM-Bluemix/go-etcd-rules/rules/static_rule.go (100.0%)</option>
				
				<option value="file14">github.com/IBM-Bluemix/go-etcd-rules/rules/watcher.go (86.2%)</option>
				
				<option value="file15">github.com/IBM-Bluemix/go-etcd-rules/rules/worker.go (84.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rules

import (
        "sync/atomic"
)

func is(val *uint32) bool <span class="cov10" title="4275751">{
        return (atomic.LoadUint32(val)) == 1
}</span>

func atomicSet(val *uint32, b bool) <span class="cov3" title="84">{
        var r uint32
        if b </span><span class="cov3" title="50">{
                r = 1
        }</span><span class="cov3" title="34"> else {
                r = 0
        }</span>
        <span class="cov3" title="84">atomic.StoreUint32(val, r)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package rules

import (
        "sync"
        "time"

        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
        "golang.org/x/net/context"
)

type crawler interface {
        run()
        stop()
        isStopped() bool
}

func newCrawler(
        config client.Config,
        logger zap.Logger,
        prefix string,
        interval int,
        kp keyProc,
        wrapKeysAPI WrapKeysAPI,
        delay int,
) (crawler, error) <span class="cov2" title="6">{
        blank := etcdCrawler{}
        cl, err1 := client.New(config)
        if err1 != nil </span><span class="cov1" title="1">{
                return &amp;blank, err1
        }</span>
        <span class="cov2" title="5">kapi := wrapKeysAPI(client.NewKeysAPI(cl))
        api := etcdReadAPI{
                keysAPI: kapi,
        }
        c := etcdCrawler{
                baseCrawler: baseCrawler{
                        api:      &amp;api,
                        interval: interval,
                        kp:       kp,
                        logger:   logger,
                        prefix:   prefix,
                        delay:    delay,
                },
                kapi: kapi,
        }
        return &amp;c, nil</span>
}

func newV3Crawler(
        config clientv3.Config,
        interval int,
        kp keyProc,
        logger zap.Logger,
        mutex *string,
        mutexTTL int,
        prefix string,
        kvWrapper WrapKV,
) (crawler, error) <span class="cov1" title="2">{
        blank := etcdCrawler{}
        cl, err1 := clientv3.New(config)
        if err1 != nil </span><span class="cov1" title="1">{
                return &amp;blank, err1
        }</span>
        <span class="cov1" title="1">kv := kvWrapper(clientv3.NewKV(cl))
        api := etcdV3ReadAPI{
                kV: kv,
        }
        c := v3EtcdCrawler{
                baseCrawler: baseCrawler{
                        api:      &amp;api,
                        interval: interval,
                        kp:       kp,
                        logger:   logger,
                        mutex:    mutex,
                        mutexTTL: mutexTTL,
                        prefix:   prefix,
                },
                cl: cl,
                kv: kv,
        }
        return &amp;c, nil</span>
}

type baseCrawler struct {
        api         readAPI
        cancelFunc  context.CancelFunc
        cancelMutex sync.Mutex
        interval    int
        delay       int
        kp          keyProc
        logger      zap.Logger
        mutex       *string
        mutexTTL    int
        prefix      string
        stopping    uint32
        stopped     uint32
}

func (bc *baseCrawler) isStopping() bool <span class="cov3" title="75">{
        return is(&amp;bc.stopping)
}</span>

func (bc *baseCrawler) stop() <span class="cov1" title="2">{
        atomicSet(&amp;bc.stopping, true)
        bc.cancelMutex.Lock()
        defer bc.cancelMutex.Unlock()
        if bc.cancelFunc != nil </span><span class="cov0" title="0">{
                bc.cancelFunc()
        }</span>
}

func (bc *baseCrawler) isStopped() bool <span class="cov10" title="1537351">{
        return is(&amp;bc.stopped)
}</span>

type etcdCrawler struct {
        baseCrawler
        kapi client.KeysAPI
}

func (ec *etcdCrawler) run() <span class="cov1" title="4">{
        atomicSet(&amp;ec.stopped, false)
        for !ec.isStopping() </span><span class="cov1" title="4">{
                ec.logger.Debug("Starting crawler run")
                ec.singleRun()
                ec.logger.Debug("Crawler run complete")
                for i := 0; i &lt; ec.interval; i++ </span><span class="cov3" title="60">{
                        time.Sleep(time.Second)
                        if ec.isStopping() </span><span class="cov1" title="2">{
                                break</span>
                        }
                }
        }
        <span class="cov1" title="2">atomicSet(&amp;ec.stopped, true)</span>
}

func (ec *etcdCrawler) singleRun() <span class="cov2" title="6">{
        ec.crawlPath(ec.prefix)
}</span>

func (ec *etcdCrawler) crawlPath(path string) <span class="cov2" title="7">{
        if ec.isStopping() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="7">ctx := context.Background()
        ctx = SetMethod(ctx, "crawler")
        time.Sleep(time.Millisecond * time.Duration(ec.delay))
        resp, err := ec.kapi.Get(ctx, path, nil)
        if err != nil </span><span class="cov2" title="5">{
                return
        }</span>
        <span class="cov1" title="2">if resp.Node.Dir </span><span class="cov1" title="1">{
                for _, node := range resp.Node.Nodes </span><span class="cov1" title="1">{
                        ec.crawlPath(node.Key)
                }</span>
                <span class="cov1" title="1">return</span>
        }
        <span class="cov1" title="1">node := resp.Node
        logger := ec.logger.With(zap.String("source", "crawler"))
        ec.kp.processKey(node.Key, &amp;node.Value, ec.api, logger, map[string]string{"source": "crawler", "prefix": ec.prefix})</span>
}

type v3EtcdCrawler struct {
        baseCrawler
        cl *clientv3.Client
        kv clientv3.KV
}

func (v3ec *v3EtcdCrawler) run() <span class="cov0" title="0">{
        atomicSet(&amp;v3ec.stopped, false)
        for !v3ec.isStopping() </span><span class="cov0" title="0">{
                v3ec.logger.Debug("Starting crawler run")
                if v3ec.mutex == nil </span><span class="cov0" title="0">{
                        v3ec.singleRun()
                }</span><span class="cov0" title="0"> else {
                        mutex := "/crawler/" + *v3ec.mutex + v3ec.prefix
                        v3ec.logger.Debug("Attempting to obtain mutex",
                                zap.String("mutex", mutex), zap.Int("TTL", v3ec.mutexTTL))
                        locker := newV3Locker(v3ec.cl)
                        lock, err := locker.lock(mutex, v3ec.mutexTTL)
                        if err != nil </span><span class="cov0" title="0">{
                                v3ec.logger.Debug("Could not obtain mutex; skipping crawler run", zap.Error(err))
                        }</span><span class="cov0" title="0"> else {
                                v3ec.singleRun()
                                lock.unlock()
                        }</span>
                }
                <span class="cov0" title="0">v3ec.logger.Debug("Crawler run complete")
                for i := 0; i &lt; v3ec.interval; i++ </span><span class="cov0" title="0">{
                        time.Sleep(time.Second)
                        if v3ec.isStopping() </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">atomicSet(&amp;v3ec.stopped, true)</span>
}

func (v3ec *v3EtcdCrawler) singleRun() <span class="cov1" title="2">{
        if v3ec.isStopping() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="2">ctx, cancelFunc := context.WithTimeout(context.Background(), time.Duration(1)*time.Minute)
        ctx = SetMethod(ctx, "crawler")
        v3ec.cancelMutex.Lock()
        v3ec.cancelFunc = cancelFunc
        v3ec.cancelMutex.Unlock()
        resp, err := v3ec.kv.Get(ctx, v3ec.prefix, clientv3.WithPrefix())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="2">logger := v3ec.logger.With(zap.String("source", "crawler"))
        for _, kv := range resp.Kvs </span><span class="cov1" title="2">{
                if v3ec.isStopping() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="2">value := string(kv.Value[:])
                v3ec.kp.processKey(string(kv.Key[:]), &amp;value, v3ec.api, logger, map[string]string{"source": "crawler", "prefix": v3ec.prefix})</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rules

import ()

// DynamicRule defines rules that have dynamic key paths so that classes of keys can be
// referenced in rules.
type DynamicRule interface {
        makeStaticRule(key string, value *string) (staticRule, Attributes, bool)
        staticRuleFromAttributes(attr Attributes) staticRule
        getPatterns() []string
        getPrefixes() []string
        getPrefixesWithConstraints(constraints map[string]constraint) []string
        expand(map[string][]string) ([]DynamicRule, bool)
}

func newDynamicRule(factory ruleFactory, patterns []string, attributes ...attributeInstance) (DynamicRule, error) <span class="cov8" title="44">{
        matchers := make([]keyMatcher, len(patterns))
        prefixes := make([]string, len(patterns))
        for i, v := range patterns </span><span class="cov8" title="45">{
                matcher, err := newRegexKeyMatcher(v)
                if err != nil </span><span class="cov3" title="3">{
                        return nil, err
                }</span>
                <span class="cov8" title="42">matchers[i] = matcher
                prefixes[i] = matcher.getPrefix()</span>
        }
        <span class="cov7" title="41">pattern := dynamicRule{
                factory:    factory,
                matchers:   matchers,
                patterns:   patterns,
                prefixes:   prefixes,
                attributes: attributes,
        }
        return &amp;pattern, nil</span>
}

type dynamicRule struct {
        factory    ruleFactory
        matchers   []keyMatcher
        patterns   []string
        prefixes   []string
        attributes []attributeInstance
}

func (krp *dynamicRule) expand(valueMap map[string][]string) ([]DynamicRule, bool) <span class="cov9" title="93">{
        params := map[string]string{}
        for _, pattern := range krp.patterns </span><span class="cov9" title="93">{
                fieldsToParms, _ := parsePath(pattern)
                for parm := range fieldsToParms </span><span class="cov10" title="119">{
                        params[parm] = ""
                }</span>
        }
        <span class="cov9" title="93">expanded := false
        out := []DynamicRule{}
        // Iterate through all parameters in the rule's key patterns
        for param := range params </span><span class="cov9" title="102">{
                // See if the parameter is in the provided value map
                values, ok := valueMap[param]
                if ok </span><span class="cov6" title="15">{
                        expanded = true
                        // Iterate through all values for the parameter in the value map
                        for _, value := range values </span><span class="cov6" title="18">{
                                newPatterns := []string{}
                                attrs := mapAttributes{values: map[string]string{param: value}}
                                for _, pattern := range krp.patterns </span><span class="cov6" title="18">{
                                        newPatterns = append(newPatterns, formatWithAttributes(pattern, &amp;attrs))
                                }</span>
                                // Create a new rule instance for each value in the value map
                                <span class="cov6" title="18">newAttributes := []attributeInstance{}
                                newAttributes = append(newAttributes, krp.attributes...)
                                // Need a new variable because the value memory location is reused during
                                // each loop iteration
                                valref := value
                                newAttributes = append(newAttributes, attributeInstance{key: param, value: &amp;valref})
                                rule, err := newDynamicRule(krp.factory, newPatterns, newAttributes...)
                                // Expand the new rule instance
                                if err == nil </span><span class="cov6" title="18">{
                                        exp, _ := rule.expand(valueMap)
                                        out = append(out, exp...)
                                }</span>
                        }
                        <span class="cov6" title="15">break</span>
                }
        }
        <span class="cov9" title="93">if !expanded </span><span class="cov9" title="78">{
                out = append(out, krp)
        }</span>
        <span class="cov9" title="93">return out, expanded</span>
}

func (krp *dynamicRule) getPatterns() []string <span class="cov9" title="100">{
        return krp.patterns
}</span>

func (krp *dynamicRule) getPrefixes() []string <span class="cov9" title="91">{
        return krp.prefixes
}</span>

func (krp *dynamicRule) getPrefixesWithConstraints(constraints map[string]constraint) []string <span class="cov6" title="17">{
        prefixes := []string{}
        for _, km := range krp.matchers </span><span class="cov6" title="17">{
                matchPrefixes := km.getPrefixesWithConstraints(constraints)
                prefixes = append(prefixes, matchPrefixes...)
        }</span>
        <span class="cov6" title="17">return prefixes</span>
}

type attributeInstance struct {
        key   string
        value *string
}

type nestingAttributes struct {
        nested Attributes
        attrs  []attributeInstance
}

func (na *nestingAttributes) GetAttribute(key string) *string <span class="cov9" title="81">{
        for _, attribute := range na.attrs </span><span class="cov8" title="60">{
                if attribute.key == key </span><span class="cov6" title="24">{
                        return attribute.value
                }</span>
        }
        <span class="cov8" title="57">return na.nested.GetAttribute(key)</span>
}

func (na *nestingAttributes) Format(pattern string) string <span class="cov3" title="4">{
        return formatWithAttributes(pattern, na)
}</span>

func (krp *dynamicRule) makeStaticRule(key string, value *string) (staticRule, Attributes, bool) <span class="cov8" title="58">{
        var match keyMatch
        anyMatch := false
        for _, matcher := range krp.matchers </span><span class="cov8" title="59">{
                m, ok := matcher.match(key)
                if ok </span><span class="cov6" title="20">{
                        match = m
                        anyMatch = true
                        break</span>
                }
        }
        <span class="cov8" title="58">if anyMatch </span><span class="cov6" title="20">{
                keys := make([]string, len(krp.matchers))
                for i, matcher := range krp.matchers </span><span class="cov6" title="21">{
                        keys[i] = match.Format(matcher.getPattern())
                }</span>
                <span class="cov6" title="20">attr := nestingAttributes{attrs: krp.attributes, nested: match}
                sr := krp.factory.newRule(keys, &amp;attr)
                return sr, &amp;attr, true</span>
        }
        <span class="cov7" title="38">return nil, nil, false</span>
}

func (krp *dynamicRule) staticRuleFromAttributes(attr Attributes) staticRule <span class="cov6" title="23">{
        keys := make([]string, len(krp.matchers))
        for i, matcher := range krp.matchers </span><span class="cov6" title="23">{
                keys[i] = formatWithAttributes(matcher.getPattern(), attr)
        }</span>
        <span class="cov6" title="23">sr := krp.factory.newRule(keys, attr)
        return sr</span>
}

// NewEqualsLiteralRule creates a rule that compares the provided string value with the
// value of a node whose key matches the provided key pattern. A nil value indicates that
// there is no node with the given key.
func NewEqualsLiteralRule(pattern string, value *string) (DynamicRule, error) <span class="cov7" title="25">{
        f := newEqualsLiteralRuleFactory(value)
        return newDynamicRule(f, []string{pattern})
}</span>

type compoundDynamicRule struct {
        nestedDynamicRules []DynamicRule
        patterns           []string
        prefixes           []string
}

func (cdr *compoundDynamicRule) makeStaticRule(key string, value *string) (*compoundStaticRule, Attributes, bool) <span class="cov6" title="22">{
        anySatisfiable := false
        var validAttr Attributes
        for _, nestedRule := range cdr.nestedDynamicRules </span><span class="cov7" title="34">{
                rule, attr, ok := nestedRule.makeStaticRule(key, value)
                if !ok </span><span class="cov6" title="24">{
                        continue</span>
                }
                <span class="cov5" title="10">anySatisfiable = rule.satisfiable(key, value)
                if anySatisfiable </span><span class="cov5" title="10">{
                        validAttr = attr
                        break</span>
                }
        }
        <span class="cov6" title="22">if !anySatisfiable </span><span class="cov5" title="12">{
                return nil, nil, false
        }</span>
        <span class="cov5" title="10">rule := cdr.staticRuleFromAttributes(validAttr)
        return rule, validAttr, true</span>
}

func (cdr *compoundDynamicRule) staticRuleFromAttributes(validAttr Attributes) *compoundStaticRule <span class="cov5" title="12">{

        staticRules := make([]staticRule, len(cdr.nestedDynamicRules))
        for i, nestedRule := range cdr.nestedDynamicRules </span><span class="cov6" title="22">{
                rule := nestedRule.staticRuleFromAttributes(validAttr)
                staticRules[i] = rule
        }</span>
        <span class="cov5" title="12">out := compoundStaticRule{
                nestedRules: staticRules,
        }
        return &amp;out</span>
}

func newCompoundDynamicRule(rules []DynamicRule) compoundDynamicRule <span class="cov8" title="47">{
        var patterns []string
        var prefixes []string
        for _, rule := range rules </span><span class="cov9" title="90">{
                patterns = append(patterns, rule.getPatterns()...)
                prefixes = append(prefixes, rule.getPrefixes()...)
        }</span>
        <span class="cov8" title="47">cdr := compoundDynamicRule{
                nestedDynamicRules: rules,
                patterns:           patterns,
                prefixes:           prefixes,
        }
        return cdr</span>
}

func (cdr *compoundDynamicRule) getPatterns() []string <span class="cov4" title="8">{
        return cdr.patterns
}</span>

func (cdr *compoundDynamicRule) getPrefixes() []string <span class="cov3" title="4">{
        return cdr.prefixes
}</span>

type newCompoundDynamicRuleFunc func(...DynamicRule) DynamicRule

func (cdr *compoundDynamicRule) getPrefixesWithConstraints(constraints map[string]constraint) []string <span class="cov3" title="4">{
        prefixes := []string{}
        for _, nested := range cdr.nestedDynamicRules </span><span class="cov4" title="8">{
                prefixes = append(prefixes, nested.getPrefixesWithConstraints(constraints)...)
        }</span>
        <span class="cov3" title="4">return prefixes</span>
}

func (cdr *compoundDynamicRule) expand(valueMap map[string][]string,
        constructor newCompoundDynamicRuleFunc,
        dr DynamicRule) ([]DynamicRule, bool) <span class="cov5" title="9">{
        expanded := false
        out := []DynamicRule{}
        for key, values := range valueMap </span><span class="cov6" title="19">{
                keyExpansion := false
                newRules := []DynamicRule{}
                for _, value := range values </span><span class="cov7" title="36">{
                        attr := map[string][]string{key: {value}}
                        newNested := []DynamicRule{}
                        for _, nested := range cdr.nestedDynamicRules </span><span class="cov9" title="72">{
                                expandedRule, gotExpanded := nested.expand(attr)
                                if gotExpanded </span><span class="cov5" title="12">{
                                        keyExpansion = true
                                }</span>
                                <span class="cov9" title="72">newNested = append(newNested, expandedRule[0])</span>
                        }
                        <span class="cov7" title="36">newRules = append(newRules, constructor(newNested...))</span>
                }
                <span class="cov6" title="19">if keyExpansion </span><span class="cov3" title="3">{
                        expanded = true
                        for _, rule := range newRules </span><span class="cov4" title="6">{
                                expandedRules, _ := rule.expand(valueMap)
                                out = append(out, expandedRules...)
                        }</span>
                        <span class="cov3" title="3">break</span>
                }
        }
        <span class="cov5" title="9">if !expanded </span><span class="cov4" title="6">{
                out = append(out, dr)
        }</span>
        <span class="cov5" title="9">return out, expanded</span>
}

type andDynamicRule struct {
        compoundDynamicRule
}

func (adr *andDynamicRule) makeStaticRule(key string, value *string) (staticRule, Attributes, bool) <span class="cov6" title="19">{
        cdr, attr, ok := adr.compoundDynamicRule.makeStaticRule(key, value)
        if !ok </span><span class="cov5" title="12">{
                return nil, nil, false
        }</span>
        <span class="cov4" title="7">return &amp;andStaticRule{
                compoundStaticRule: *cdr,
        }, attr, ok</span>
}

func (adr *andDynamicRule) staticRuleFromAttributes(attr Attributes) staticRule <span class="cov1" title="1">{
        cdr := adr.compoundDynamicRule.staticRuleFromAttributes(attr)
        return &amp;andStaticRule{
                compoundStaticRule: *cdr,
        }
}</span>

func (adr *andDynamicRule) expand(valueMap map[string][]string) ([]DynamicRule, bool) <span class="cov5" title="9">{
        return adr.compoundDynamicRule.expand(valueMap, NewAndRule, adr)
}</span>

// NewAndRule allows two or more dynamic rules to be combined into a single rule
// such that every nested rule must be satisfied in order for the overall rule to be
// satisfied.
func NewAndRule(rules ...DynamicRule) DynamicRule <span class="cov8" title="43">{
        cdr := newCompoundDynamicRule(rules)
        rule := andDynamicRule{
                compoundDynamicRule: cdr,
        }
        return &amp;rule
}</span>

type orDynamicRule struct {
        compoundDynamicRule
}

func (odr *orDynamicRule) expand(valueMap map[string][]string) ([]DynamicRule, bool) <span class="cov0" title="0">{
        return odr.compoundDynamicRule.expand(valueMap, NewOrRule, odr)
}</span>

func (odr *orDynamicRule) makeStaticRule(key string, value *string) (staticRule, Attributes, bool) <span class="cov3" title="3">{
        cdr, attr, ok := odr.compoundDynamicRule.makeStaticRule(key, value)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, false
        }</span>
        <span class="cov3" title="3">return &amp;orStaticRule{
                compoundStaticRule: *cdr,
        }, attr, ok</span>
}

func (odr *orDynamicRule) staticRuleFromAttributes(attr Attributes) staticRule <span class="cov1" title="1">{
        cdr := odr.compoundDynamicRule.staticRuleFromAttributes(attr)
        return &amp;orStaticRule{
                compoundStaticRule: *cdr,
        }
}</span>

// NewOrRule allows two or more dynamic rules to be combined into a single rule
// such that at least one nested rule must be satisfied in order for the overall rule to be
// satisfied.
func NewOrRule(rules ...DynamicRule) DynamicRule <span class="cov2" title="2">{
        cdr := newCompoundDynamicRule(rules)
        rule := orDynamicRule{
                compoundDynamicRule: cdr,
        }
        return &amp;rule
}</span>

type notDynamicRule struct {
        compoundDynamicRule
}

func (ndr *notDynamicRule) expand(valueMap map[string][]string) ([]DynamicRule, bool) <span class="cov0" title="0">{
        return ndr.compoundDynamicRule.expand(valueMap, newNotRule, ndr)
}</span>

func newNotRule(rules ...DynamicRule) DynamicRule <span class="cov0" title="0">{
        cdr := newCompoundDynamicRule(rules)
        rule := notDynamicRule{
                compoundDynamicRule: cdr,
        }
        return &amp;rule
}</span>

func (ndr *notDynamicRule) makeStaticRule(key string, value *string) (staticRule, Attributes, bool) <span class="cov2" title="2">{
        ns, attr, ok := ndr.nestedDynamicRules[0].makeStaticRule(key, value)
        nsr := notStaticRule{
                nested: ns,
        }
        return &amp;nsr, attr, ok
}</span>

func (ndr *notDynamicRule) staticRuleFromAttributes(attr Attributes) staticRule <span class="cov1" title="1">{
        nsr := notStaticRule{
                nested: ndr.nestedDynamicRules[0].staticRuleFromAttributes(attr),
        }
        return &amp;nsr
}</span>

func (ndr *notDynamicRule) getPatterns() []string <span class="cov1" title="1">{
        return ndr.nestedDynamicRules[0].getPatterns()
}</span>

func (ndr *notDynamicRule) getPrefixes() []string <span class="cov1" title="1">{
        return ndr.nestedDynamicRules[0].getPrefixes()
}</span>

// NewNotRule allows a rule to be negated such that if the
// nested rule's key matches but the rule is otherwise not
// satisfied, the not rule is satisfied. This is to enable
// capabilities such as checking whether a given key is
// set, i.e. its value is not nil.
func NewNotRule(nestedRule DynamicRule) DynamicRule <span class="cov2" title="2">{
        r := []DynamicRule{nestedRule}
        cdr := newCompoundDynamicRule(r)

        ndr := notDynamicRule{
                compoundDynamicRule: cdr,
        }
        return &amp;ndr
}</span>

// NewEqualsRule enables the comparison of two or more node
// values with the specified key patterns.
func NewEqualsRule(pattern []string) (DynamicRule, error) <span class="cov1" title="1">{
        f := newEqualsRuleFactory()
        return newDynamicRule(f, pattern)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package rules

import (
        "fmt"
        "strings"
        "time"

        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
        "golang.org/x/net/context"
)

type stopable interface {
        stop()
        isStopped() bool
}

type BaseEngine interface {
        Run()
        Stop()
        IsStopped() bool
}

type baseEngine struct {
        cCloser      channelCloser
        keyProc      setableKeyProcessor
        logger       zap.Logger
        options      engineOptions
        ruleLockTTLs map[int]int
        ruleMgr      ruleManager
        stopped      uint32
        crawlers     []stopable
        watchers     []stopable
        workers      []stopable
}

type channelCloser func()

type engine struct {
        baseEngine
        config         client.Config
        keyProc        keyProcessor
        workChannel    chan ruleWork
        keysAPIWrapper WrapKeysAPI
}

type v3Engine struct {
        baseEngine
        configV3    clientv3.Config
        keyProc     v3KeyProcessor
        workChannel chan v3RuleWork
        kvWrapper   WrapKV
}

// Engine defines the interactions with a rule engine instance.
type Engine interface {
        BaseEngine
        SetKeysAPIWrapper(WrapKeysAPI)
        AddRule(rule DynamicRule,
                lockPattern string,
                callback RuleTaskCallback,
                options ...RuleOption)
        AddPolling(namespacePattern string,
                preconditions DynamicRule,
                ttl int,
                callback RuleTaskCallback) error
}

// V3Engine defines the interactions with a rule engine instance communicating with etcd v3.
type V3Engine interface {
        BaseEngine
        SetKVWrapper(WrapKV)
        AddRule(rule DynamicRule,
                lockPattern string,
                callback V3RuleTaskCallback,
                options ...RuleOption)
        AddPolling(namespacePattern string,
                preconditions DynamicRule,
                ttl int,
                callback V3RuleTaskCallback) error
}

// NewEngine creates a new Engine instance.
func NewEngine(config client.Config, logger zap.Logger, options ...EngineOption) Engine <span class="cov1" title="2">{
        eng := newEngine(config, clientv3.Config{}, false, logger, options...)
        return &amp;eng
}</span>

// NewV3Engine creates a new V3Engine instance.
func NewV3Engine(configV3 clientv3.Config, logger zap.Logger, options ...EngineOption) V3Engine <span class="cov1" title="2">{
        eng := newV3Engine(client.Config{}, configV3, true, logger, options...)
        return &amp;eng
}</span>

func newEngine(config client.Config, configV3 clientv3.Config, useV3 bool, logger zap.Logger, options ...EngineOption) engine <span class="cov1" title="3">{
        opts := makeEngineOptions(options...)
        ruleMgr := newRuleManager(map[string]constraint{})
        channel := make(chan ruleWork)
        keyProc := newKeyProcessor(channel, config, &amp;ruleMgr)
        eng := engine{
                baseEngine: baseEngine{
                        cCloser: func() </span><span class="cov1" title="1">{
                                close(channel)
                        }</span>,
                        keyProc:      &amp;keyProc,
                        logger:       logger,
                        options:      opts,
                        ruleLockTTLs: map[int]int{},
                        ruleMgr:      ruleMgr,
                },
                config:         config,
                keyProc:        keyProc,
                workChannel:    channel,
                keysAPIWrapper: defaultWrapKeysAPI,
        }
        <span class="cov1" title="3">return eng</span>
}

func newV3Engine(config client.Config, configV3 clientv3.Config, useV3 bool, logger zap.Logger, options ...EngineOption) v3Engine <span class="cov1" title="2">{
        opts := makeEngineOptions(options...)
        ruleMgr := newRuleManager(opts.constraints)
        channel := make(chan v3RuleWork)
        keyProc := newV3KeyProcessor(channel, &amp;configV3, &amp;ruleMgr)
        eng := v3Engine{
                baseEngine: baseEngine{
                        cCloser: func() </span><span class="cov1" title="1">{
                                close(channel)
                        }</span>,
                        keyProc:      &amp;keyProc,
                        logger:       logger,
                        options:      opts,
                        ruleLockTTLs: map[int]int{},
                        ruleMgr:      ruleMgr,
                },
                configV3:    configV3,
                keyProc:     keyProc,
                workChannel: channel,
                kvWrapper:   defaultWrapKV,
        }
        <span class="cov1" title="2">return eng</span>
}

func (e *engine) SetKeysAPIWrapper(keysAPIWrapper WrapKeysAPI) <span class="cov0" title="0">{
        e.keysAPIWrapper = keysAPIWrapper
}</span>

func (e *v3Engine) SetKVWrapper(kvWrapper WrapKV) <span class="cov0" title="0">{
        e.kvWrapper = kvWrapper
}</span>

func (e *engine) AddRule(rule DynamicRule,
        lockPattern string,
        callback RuleTaskCallback,
        options ...RuleOption) <span class="cov1" title="4">{
        e.addRuleWithIface(rule, lockPattern, callback, options...)
}</span>

func (e *v3Engine) AddRule(rule DynamicRule,
        lockPattern string,
        callback V3RuleTaskCallback,
        options ...RuleOption) <span class="cov1" title="4">{
        e.addRuleWithIface(rule, lockPattern, callback, options...)
}</span>

func (e *baseEngine) Stop() <span class="cov1" title="2">{
        e.logger.Info("Stopping engine")
        go e.stop()
}</span>

func (e *baseEngine) stop() <span class="cov1" title="2">{
        e.logger.Debug("Stopping crawlers")
        stopStopables(e.crawlers)
        e.logger.Debug("Stopping watchers")
        stopStopables(e.watchers)
        e.logger.Debug("Stopping workers")
        for _, worker := range e.workers </span><span class="cov2" title="10">{
                worker.stop()
        }</span>
        <span class="cov1" title="2">e.logger.Debug("Closing work channel")
        e.cCloser()
        // Ensure workers are stopped; the "stop" method is called again, but
        // that is idempotent.  The workers' "stop" method must be called before
        // the channel is closed in order to avoid nil pointer dereference panics.
        stopStopables(e.workers)
        atomicSet(&amp;e.stopped, true)
        e.logger.Info("Engine stopped")</span>
}

func stopStopables(stopables []stopable) <span class="cov2" title="6">{
        for _, s := range stopables </span><span class="cov2" title="17">{
                s.stop()
        }</span>
        <span class="cov2" title="6">allStopped := false
        for !allStopped </span><span class="cov9" title="4275558">{
                allStopped = true
                for _, s := range stopables </span><span class="cov10" title="7391655">{
                        allStopped = allStopped &amp;&amp; s.isStopped()
                }</span>
        }
}

func (e *baseEngine) IsStopped() bool <span class="cov2" title="6">{
        return is(&amp;e.stopped)
}</span>

func (e *baseEngine) addRuleWithIface(rule DynamicRule, lockPattern string, callback interface{}, options ...RuleOption) <span class="cov2" title="8">{
        if len(e.options.keyExpansion) &gt; 0 </span><span class="cov1" title="4">{
                rules, _ := rule.expand(e.options.keyExpansion)
                for _, expRule := range rules </span><span class="cov1" title="4">{
                        e.addRule(expRule, lockPattern, callback, options...)
                }</span>
        }<span class="cov1" title="4"> else {
                e.addRule(rule, lockPattern, callback, options...)
        }</span>
}

func (e *engine) AddPolling(namespacePattern string, preconditions DynamicRule, ttl int, callback RuleTaskCallback) error <span class="cov1" title="3">{
        if !strings.HasSuffix(namespacePattern, "/") </span><span class="cov1" title="3">{
                namespacePattern = namespacePattern + "/"
        }</span>
        <span class="cov1" title="3">ttlPathPattern := namespacePattern + "ttl"
        ttlRule, err := NewEqualsLiteralRule(ttlPathPattern, nil)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="2">rule := NewAndRule(preconditions, ttlRule)
        cbw := callbackWrapper{
                callback:       callback,
                ttl:            ttl,
                ttlPathPattern: ttlPathPattern,
        }
        e.AddRule(rule, namespacePattern+"lock", cbw.doRule)
        return nil</span>
}

func (e *v3Engine) AddPolling(namespacePattern string, preconditions DynamicRule, ttl int, callback V3RuleTaskCallback) error <span class="cov1" title="3">{
        if !strings.HasSuffix(namespacePattern, "/") </span><span class="cov1" title="3">{
                namespacePattern = namespacePattern + "/"
        }</span>
        <span class="cov1" title="3">ttlPathPattern := namespacePattern + "ttl"
        ttlRule, err := NewEqualsLiteralRule(ttlPathPattern, nil)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="2">rule := NewAndRule(preconditions, ttlRule)
        cbw := v3CallbackWrapper{
                callback:       callback,
                ttl:            ttl,
                ttlPathPattern: ttlPathPattern,
        }
        e.AddRule(rule, "/rule_locks"+namespacePattern+"lock", cbw.doRule)
        return nil</span>
}

func (e *baseEngine) addRule(rule DynamicRule,
        lockPattern string,
        callback interface{},
        options ...RuleOption) <span class="cov2" title="8">{
        ruleIndex := e.ruleMgr.addRule(rule)
        opts := makeRuleOptions(options...)
        ttl := e.options.lockTimeout
        if opts.lockTimeout &gt; 0 </span><span class="cov1" title="2">{
                ttl = opts.lockTimeout
        }</span>
        <span class="cov2" title="8">contextProvider := opts.contextProvider
        if contextProvider == nil </span><span class="cov2" title="8">{
                contextProvider = e.options.contextProvider
        }</span>
        <span class="cov2" title="8">e.ruleLockTTLs[ruleIndex] = ttl
        e.keyProc.setCallback(ruleIndex, callback)
        e.keyProc.setLockKeyPattern(ruleIndex, lockPattern)
        e.keyProc.setContextProvider(ruleIndex, contextProvider)</span>
}

func (e *engine) Run() <span class="cov1" title="2">{
        prefixes := e.ruleMgr.prefixes

        // This is a map; used to ensure there are no duplicates
        for prefix := range prefixes </span><span class="cov1" title="4">{
                logger := e.logger.With(zap.String("prefix", prefix))
                c, err1 := newCrawler(
                        e.config,
                        logger,
                        prefix,
                        e.options.syncInterval,
                        e.baseEngine.keyProc,
                        e.keysAPIWrapper,
                        e.options.syncDelay,
                )
                if err1 != nil </span><span class="cov0" title="0">{
                        e.logger.Fatal("Failed to initialize crawler", zap.String("prefix", prefix), zap.Error(err1))
                }</span>
                <span class="cov1" title="4">e.crawlers = append(e.crawlers, c)
                go c.run()
                w, err := newWatcher(e.config, prefix, logger, e.baseEngine.keyProc, e.options.watchTimeout, e.keysAPIWrapper)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Fatal("Failed to initialize watcher", zap.String("prefix", prefix))
                }</span>
                <span class="cov1" title="4">e.watchers = append(e.watchers, &amp;w)
                go w.run()</span>
        }

        <span class="cov1" title="2">for i := 0; i &lt; e.options.concurrency; i++ </span><span class="cov2" title="10">{
                id := fmt.Sprintf("worker%d", i)
                w, err := newWorker(id, e)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Fatal("Failed to start worker", zap.String("worker", id), zap.Error(err))
                }</span>
                <span class="cov2" title="10">e.workers = append(e.workers, &amp;w)
                go w.run()</span>
        }

}

func (e *v3Engine) Run() <span class="cov1" title="2">{
        prefixSlice := []string{}
        prefixes := e.ruleMgr.prefixes
        // This is a map; used to ensure there are no duplicates
        for prefix := range prefixes </span><span class="cov1" title="4">{
                prefixSlice = append(prefixSlice, prefix)
                logger := e.logger.With(zap.String("prefix", prefix))
                w, err := newV3Watcher(e.configV3, prefix, logger, e.baseEngine.keyProc, e.options.watchTimeout, e.kvWrapper)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Fatal("Failed to initialize watcher", zap.String("prefix", prefix))
                }</span>
                <span class="cov1" title="4">e.watchers = append(e.watchers, &amp;w)
                go w.run()</span>
        }
        <span class="cov1" title="2">logger := e.logger
        c, err := newIntCrawler(e.configV3,
                e.options.syncInterval,
                e.baseEngine.keyProc,
                logger,
                e.options.crawlMutex,
                e.options.crawlerTTL,
                prefixSlice,
                e.kvWrapper,
                e.options.syncDelay)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Fatal("Failed to initialize crawler", zap.Error(err))
        }</span>
        <span class="cov1" title="2">e.crawlers = append(e.crawlers, c)
        go c.run()

        for i := 0; i &lt; e.options.concurrency; i++ </span><span class="cov2" title="10">{
                id := fmt.Sprintf("worker%d", i)
                w, err := newV3Worker(id, e)
                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Fatal("Failed to start worker", zap.String("worker", id), zap.Error(err))
                }</span>
                <span class="cov2" title="10">e.workers = append(e.workers, &amp;w)
                go w.run()</span>
        }

}

func (e *baseEngine) getLockTTLForRule(index int) int <span class="cov1" title="3">{
        return e.ruleLockTTLs[index]
}</span>

type callbackWrapper struct {
        ttlPathPattern string
        callback       RuleTaskCallback
        ttl            int
}

type v3CallbackWrapper struct {
        ttlPathPattern string
        callback       V3RuleTaskCallback
        ttl            int
}

func (cbw *callbackWrapper) doRule(task *RuleTask) <span class="cov1" title="3">{
        logger := task.Logger
        cbw.callback(task)
        c, err := client.New(task.Conf)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Error obtaining client", zap.Error(err))
                return
        }</span>
        <span class="cov1" title="2">kapi := client.NewKeysAPI(c)
        path := task.Attr.Format(cbw.ttlPathPattern)
        logger.Debug("Setting polling TTL", zap.String("path", path))
        _, setErr := kapi.Set(
                context.Background(),
                path,
                "",
                &amp;client.SetOptions{TTL: time.Duration(cbw.ttl) * time.Second},
        )
        if setErr != nil </span><span class="cov1" title="1">{
                logger.Error("Error setting polling TTL", zap.Error(setErr), zap.String("path", path))
        }</span>
}

func (cbw *v3CallbackWrapper) doRule(task *V3RuleTask) <span class="cov1" title="3">{
        logger := task.Logger
        cbw.callback(task)
        c, err := clientv3.New(*task.Conf)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Error obtaining client", zap.Error(err))
                return
        }</span>
        <span class="cov1" title="2">kv := clientv3.NewKV(c)
        path := task.Attr.Format(cbw.ttlPathPattern)
        logger.Debug("Setting polling TTL", zap.String("path", path))
        lease := clientv3.NewLease(c)
        ctx, cancelFunc := context.WithTimeout(context.Background(), time.Duration(5)*time.Second)
        defer cancelFunc()
        resp, leaseErr := lease.Grant(ctx, int64(cbw.ttl))
        if leaseErr != nil </span><span class="cov1" title="1">{
                logger.Error("Error obtaining lease", zap.Error(leaseErr), zap.String("path", path))
                return
        }</span>
        <span class="cov1" title="1">ctx1, cancelFunc1 := context.WithTimeout(context.Background(), time.Duration(5)*time.Second)
        defer cancelFunc1()
        _, setErr := kv.Put(
                ctx1,
                path,
                "",
                clientv3.WithLease(resp.ID),
        )
        if setErr != nil </span><span class="cov0" title="0">{
                logger.Error("Error setting polling TTL", zap.Error(setErr), zap.String("path", path))
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rules

import (
        "strings"
        "sync"
        "time"

        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "golang.org/x/net/context"
)

type baseReadAPI struct {
        cancelFunc context.CancelFunc
}

func (bra *baseReadAPI) getContext() context.Context <span class="cov6" title="4">{
        var ctx context.Context
        ctx, bra.cancelFunc = context.WithTimeout(context.Background(), time.Duration(60)*time.Second)
        return ctx
}</span>

func (bra *baseReadAPI) cancel() <span class="cov6" title="4">{
        bra.cancelFunc()
}</span>

type etcdReadAPI struct {
        baseReadAPI
        keysAPI client.KeysAPI
}

func (edra *etcdReadAPI) get(key string) (*string, error) <span class="cov3" title="2">{
        ctx := edra.getContext()
        defer edra.cancel()
        resp, err := edra.keysAPI.Get(ctx, key, nil)
        if err != nil </span><span class="cov1" title="1">{
                if !strings.HasPrefix(err.Error(), "100") </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }
        <span class="cov1" title="1">return &amp;resp.Node.Value, nil</span>
}

type etcdV3ReadAPI struct {
        baseReadAPI
        kV clientv3.KV
}

func (edv3ra *etcdV3ReadAPI) get(key string) (*string, error) <span class="cov3" title="2">{
        ctx := edv3ra.baseReadAPI.getContext()
        defer edv3ra.cancel()
        resp, err := edv3ra.kV.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="2">if resp.Count == 0 </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">val := string(resp.Kvs[0].Value)
        return &amp;val, nil</span>
}

type keyWatcher interface {
        next() (string, *string, error)
        cancel()
}

func newEtcdKeyWatcher(api client.KeysAPI, prefix string, timeout time.Duration) keyWatcher <span class="cov7" title="5">{
        w := api.Watcher(prefix, &amp;client.WatcherOptions{
                Recursive: true,
        })
        watcher := etcdKeyWatcher{
                baseKeyWatcher: baseKeyWatcher{
                        prefix:  prefix,
                        timeout: timeout,
                },
                api: api,
                w:   w,
        }
        return &amp;watcher
}</span>

func newEtcdV3KeyWatcher(watcher clientv3.Watcher, prefix string, timeout time.Duration) *etcdV3KeyWatcher <span class="cov7" title="5">{
        kw := etcdV3KeyWatcher{
                baseKeyWatcher: baseKeyWatcher{
                        prefix:  prefix,
                        timeout: timeout,
                },
                w: watcher,
        }
        return &amp;kw
}</span>

type baseKeyWatcher struct {
        cancelFunc  context.CancelFunc
        cancelMutex sync.Mutex
        prefix      string
        timeout     time.Duration
        stopping    uint32
}

func (bkw *baseKeyWatcher) getContext() context.Context <span class="cov10" title="11">{
        ctx := context.Background()
        bkw.cancelMutex.Lock()
        defer bkw.cancelMutex.Unlock()
        if bkw.timeout &gt; 0 </span><span class="cov5" title="3">{
                ctx, bkw.cancelFunc = context.WithTimeout(ctx, bkw.timeout)
        }</span><span class="cov8" title="8"> else {
                ctx, bkw.cancelFunc = context.WithCancel(ctx)
        }</span>
        <span class="cov10" title="11">ctx = SetMethod(ctx, "watcher")
        return ctx</span>
}

type etcdKeyWatcher struct {
        baseKeyWatcher
        api client.KeysAPI
        w   client.Watcher
}

func (ekw *etcdKeyWatcher) next() (string, *string, error) <span class="cov7" title="6">{
        resp, err := ekw.w.Next(ekw.getContext())
        if err != nil </span><span class="cov3" title="2">{
                // Get a new watcher to clear the event index
                ekw.w = ekw.api.Watcher(ekw.prefix, &amp;client.WatcherOptions{
                        Recursive: true,
                })
                return "", nil, err
        }</span>
        <span class="cov3" title="2">node := resp.Node
        if resp.Action == "delete" || resp.Action == "expire" </span><span class="cov1" title="1">{
                return node.Key, nil, nil
        }</span>
        <span class="cov1" title="1">return node.Key, &amp;node.Value, nil</span>
}

func (bkw *baseKeyWatcher) cancel() <span class="cov6" title="4">{
        atomicSet(&amp;bkw.stopping, true)
        bkw.cancelMutex.Lock()
        defer bkw.cancelMutex.Unlock()
        if bkw.cancelFunc != nil </span><span class="cov6" title="4">{
                bkw.cancelFunc()
                bkw.cancelFunc = nil
        }</span>
}

type etcdV3KeyWatcher struct {
        baseKeyWatcher
        ch         clientv3.WatchChan
        eventIndex int
        events     []*clientv3.Event
        w          clientv3.Watcher
}

func (ev3kw *etcdV3KeyWatcher) next() (string, *string, error) <span class="cov8" title="8">{
        if is(&amp;ev3kw.stopping) </span><span class="cov3" title="2">{
                return "", nil, nil
        }</span>
        <span class="cov7" title="6">if ev3kw.ch == nil </span><span class="cov7" title="5">{
                ev3kw.ch = ev3kw.w.Watch(ev3kw.getContext(), ev3kw.prefix, clientv3.WithPrefix())
        }</span>
        <span class="cov7" title="6">if ev3kw.events == nil </span><span class="cov7" title="6">{
                ev3kw.eventIndex = 0
                wr := &lt;-ev3kw.ch
                ev3kw.events = wr.Events
        }</span>
        <span class="cov6" title="4">if len(ev3kw.events) == 0 </span><span class="cov3" title="2">{
                ev3kw.events = nil
                // This avoids a potential endless loop due to a closed channel
                ev3kw.ch = nil
                return ev3kw.next()
        }</span>
        <span class="cov3" title="2">event := ev3kw.events[ev3kw.eventIndex]
        ev3kw.eventIndex = ev3kw.eventIndex + 1
        if ev3kw.eventIndex &gt;= len(ev3kw.events) </span><span class="cov3" title="2">{
                ev3kw.events = nil
        }</span>
        <span class="cov3" title="2">key := string(event.Kv.Key[:])
        if event.Type == clientv3.EventTypeDelete </span><span class="cov1" title="1">{ // Expire?
                return key, nil, nil
        }</span>
        <span class="cov1" title="1">val := string(event.Kv.Value[:])
        return key, &amp;val, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rules

import (
        "sync"
        "time"

        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
        "golang.org/x/net/context"
)

func newIntCrawler(
        config clientv3.Config,
        interval int,
        kp extKeyProc,
        logger zap.Logger,
        mutex *string,
        mutexTTL int,
        prefixes []string,
        kvWrapper WrapKV,
        delay int,
) (crawler, error) <span class="cov1" title="2">{
        blank := etcdCrawler{}
        cl, err1 := clientv3.New(config)
        if err1 != nil </span><span class="cov0" title="0">{
                return &amp;blank, err1
        }</span>
        <span class="cov1" title="2">kv := kvWrapper(clientv3.NewKV(cl))
        api := etcdV3ReadAPI{
                kV: kv,
        }
        c := intCrawler{
                api:      &amp;api,
                cl:       cl,
                interval: interval,
                kp:       kp,
                logger:   logger,
                mutex:    mutex,
                mutexTTL: mutexTTL,
                prefixes: prefixes,
                kv:       kv,
                delay:    delay,
        }
        return &amp;c, nil</span>
}

type extKeyProc interface {
        keyProc
        isWork(string, *string, readAPI) bool
}

type cacheReadAPI struct {
        values map[string]string
}

func (cra *cacheReadAPI) get(key string) (*string, error) <span class="cov0" title="0">{
        value, ok := cra.values[key]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;value, nil</span>
}

type intCrawler struct {
        api         readAPI
        cancelFunc  context.CancelFunc
        cancelMutex sync.Mutex
        cl          *clientv3.Client
        delay       int
        interval    int
        kp          extKeyProc
        kv          clientv3.KV
        logger      zap.Logger
        mutex       *string
        mutexTTL    int
        prefixes    []string
        stopped     uint32
        stopping    uint32
}

func (ic *intCrawler) isStopping() bool <span class="cov3" title="34">{
        return is(&amp;ic.stopping)
}</span>

func (ic *intCrawler) stop() <span class="cov1" title="1">{
        atomicSet(&amp;ic.stopping, true)
        ic.cancelMutex.Lock()
        defer ic.cancelMutex.Unlock()
        if ic.cancelFunc != nil </span><span class="cov1" title="1">{
                ic.cancelFunc()
        }</span>
}

func (ic *intCrawler) isStopped() bool <span class="cov10" title="1159560">{
        return is(&amp;ic.stopped)
}</span>

func (ic *intCrawler) run() <span class="cov1" title="2">{
        atomicSet(&amp;ic.stopped, false)
        for !ic.isStopping() </span><span class="cov1" title="2">{
                ic.logger.Debug("Starting crawler run")
                if ic.mutex == nil </span><span class="cov1" title="2">{
                        ic.singleRun()
                }</span><span class="cov0" title="0"> else {
                        mutex := "/crawler/" + *ic.mutex
                        ic.logger.Debug("Attempting to obtain mutex",
                                zap.String("mutex", mutex), zap.Int("TTL", ic.mutexTTL))
                        locker := newV3Locker(ic.cl)
                        lock, err := locker.lock(mutex, ic.mutexTTL)
                        if err != nil </span><span class="cov0" title="0">{
                                ic.logger.Debug("Could not obtain mutex; skipping crawler run", zap.Error(err))
                        }</span><span class="cov0" title="0"> else {
                                ic.singleRun()
                                lock.unlock()
                        }</span>
                }
                <span class="cov1" title="2">ic.logger.Debug("Crawler run complete")
                for i := 0; i &lt; ic.interval; i++ </span><span class="cov3" title="27">{
                        time.Sleep(time.Second)
                        if ic.isStopping() </span><span class="cov1" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov1" title="1">atomicSet(&amp;ic.stopped, true)</span>
}

func (ic *intCrawler) singleRun() <span class="cov1" title="3">{
        if ic.isStopping() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="3">logger := ic.logger.With(zap.String("source", "crawler"))
        ctx, cancelFunc := context.WithTimeout(context.Background(), time.Duration(1)*time.Minute)
        defer cancelFunc()
        ctx = SetMethod(ctx, "crawler")
        ic.cancelMutex.Lock()
        ic.cancelFunc = cancelFunc
        ic.cancelMutex.Unlock()
        values := map[string]string{}
        for _, prefix := range ic.prefixes </span><span class="cov2" title="6">{
                resp, err := ic.kv.Get(ctx, prefix, clientv3.WithPrefix())
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov2" title="6">for _, kv := range resp.Kvs </span><span class="cov1" title="3">{
                        values[string(kv.Key)] = string(kv.Value)
                }</span>
        }
        <span class="cov1" title="3">api := &amp;cacheReadAPI{values: values}
        for k, v := range values </span><span class="cov1" title="2">{
                if ic.isStopping() </span><span class="cov0" title="0">{
                        return
                }</span>
                // Check to see if any rule is satisfied from cache
                <span class="cov1" title="2">if ic.kp.isWork(k, &amp;v, api) </span><span class="cov1" title="1">{
                        // Process key if it is
                        ic.kp.processKey(k, &amp;v, ic.api, logger, map[string]string{"source": "crawler"})
                }</span>
                <span class="cov1" title="2">time.Sleep(time.Duration(ic.delay) * time.Millisecond)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rules

import (
        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
)

type keyProc interface {
        processKey(key string, value *string, api readAPI, logger zap.Logger, metadata map[string]string)
}

type setableKeyProcessor interface {
        extKeyProc
        setCallback(int, interface{})
        setContextProvider(int, ContextProvider)
        setLockKeyPattern(int, string)
}

type workDispatcher interface {
        dispatchWork(index int, rule staticRule, logger zap.Logger, keyPattern string, metadata map[string]string)
}

func (kp *keyProcessor) dispatchWork(index int, rule staticRule, logger zap.Logger, keyPattern string, metadata map[string]string) <span class="cov1" title="1">{
        task := RuleTask{
                Attr:     rule.getAttributes(),
                Conf:     kp.config,
                Logger:   logger,
                Context:  kp.contextProviders[index](),
                Metadata: metadata,
        }
        work := ruleWork{
                rule:             rule,
                ruleIndex:        index,
                ruleTask:         task,
                ruleTaskCallback: kp.callbacks[index],
                lockKey:          formatWithAttributes(keyPattern, rule.getAttributes()),
        }
        kp.channel &lt;- work
}</span>

type baseKeyProcessor struct {
        contextProviders map[int]ContextProvider
        lockKeyPatterns  map[int]string
        rm               *ruleManager
}

func (bkp *baseKeyProcessor) setLockKeyPattern(index int, pattern string) <span class="cov10" title="8">{
        bkp.lockKeyPatterns[index] = pattern
}</span>

func (bkp *baseKeyProcessor) setContextProvider(index int, cp ContextProvider) <span class="cov10" title="8">{
        bkp.contextProviders[index] = cp
}</span>

type keyProcessor struct {
        baseKeyProcessor
        callbacks map[int]RuleTaskCallback
        channel   chan ruleWork
        config    client.Config
}

func (kp *keyProcessor) setCallback(index int, callback interface{}) <span class="cov7" title="4">{
        kp.callbacks[index] = callback.(RuleTaskCallback)
}</span>

type v3KeyProcessor struct {
        baseKeyProcessor
        callbacks map[int]V3RuleTaskCallback
        channel   chan v3RuleWork
        config    *clientv3.Config
}

func (v3kp *v3KeyProcessor) setCallback(index int, callback interface{}) <span class="cov7" title="4">{
        v3kp.callbacks[index] = callback.(V3RuleTaskCallback)
}</span>

func (v3kp *v3KeyProcessor) dispatchWork(index int, rule staticRule, logger zap.Logger, keyPattern string, metadata map[string]string) <span class="cov1" title="1">{
        task := V3RuleTask{
                Attr: rule.getAttributes(),
                // This line is different
                Conf:     v3kp.config,
                Logger:   logger,
                Context:  v3kp.contextProviders[index](),
                Metadata: metadata,
        }
        work := v3RuleWork{
                rule:      rule,
                ruleIndex: index,
                ruleTask:  task,
                // This line is different
                ruleTaskCallback: v3kp.callbacks[index],
                lockKey:          formatWithAttributes(keyPattern, rule.getAttributes()),
        }
        v3kp.channel &lt;- work
}</span>

func newKeyProcessor(channel chan ruleWork, config client.Config, rm *ruleManager) keyProcessor <span class="cov5" title="3">{
        kp := keyProcessor{
                baseKeyProcessor: baseKeyProcessor{
                        contextProviders: map[int]ContextProvider{},
                        lockKeyPatterns:  map[int]string{},
                        rm:               rm,
                },
                callbacks: map[int]RuleTaskCallback{},
                channel:   channel,
                config:    config,
        }
        return kp
}</span>

func newV3KeyProcessor(channel chan v3RuleWork, config *clientv3.Config, rm *ruleManager) v3KeyProcessor <span class="cov4" title="2">{
        kp := v3KeyProcessor{
                baseKeyProcessor: baseKeyProcessor{
                        contextProviders: map[int]ContextProvider{},
                        lockKeyPatterns:  map[int]string{},
                        rm:               rm,
                },
                callbacks: map[int]V3RuleTaskCallback{},
                channel:   channel,
                config:    config,
        }
        return kp
}</span>

func (kp *keyProcessor) processKey(key string, value *string, api readAPI, logger zap.Logger, metadata map[string]string) <span class="cov1" title="1">{
        kp.baseKeyProcessor.processKey(key, value, api, logger, kp, metadata)
}</span>

func (v3kp *v3KeyProcessor) processKey(key string, value *string, api readAPI, logger zap.Logger, metadata map[string]string) <span class="cov5" title="3">{
        v3kp.baseKeyProcessor.processKey(key, value, api, logger, v3kp, metadata)
}</span>

func (bkp *baseKeyProcessor) processKey(key string, value *string, api readAPI, logger zap.Logger, dispatcher workDispatcher, metadata map[string]string) <span class="cov7" title="4">{
        logger.Debug("Processing key", zap.String("key", key))
        rules := bkp.rm.getStaticRules(key, value)
        for rule, index := range rules </span><span class="cov4" title="2">{
                satisfied, _ := rule.satisfied(api)
                if satisfied </span><span class="cov4" title="2">{
                        keyPattern, ok := bkp.lockKeyPatterns[index]
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Unable to find key pattern for rule", zap.Int("index", index))
                                continue</span>
                        }
                        <span class="cov4" title="2">dispatcher.dispatchWork(index, rule, logger, keyPattern, metadata)</span>
                }
        }
}

func (bkp *baseKeyProcessor) isWork(key string, value *string, api readAPI) bool <span class="cov0" title="0">{
        rules := bkp.rm.getStaticRules(key, value)
        for rule, _ := range rules </span><span class="cov0" title="0">{
                satisfied, _ := rule.satisfied(api)
                if satisfied </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rules

import (
        "errors"
        "strings"
        "time"

        "github.com/coreos/etcd/client"
        "golang.org/x/net/context"
)

// LazyClient instances will set values only if the target value differs from the original value.
// This helps to prevent unnecessary watch events to be triggered.
type LazyClient interface {
        LazySet(key, value string) error
        LazyGet(pattern string) (*string, error)
        List(pattern string, options *client.GetOptions) ([]*client.Node, error)
}

type lazyClient struct {
        api        client.KeysAPI
        attr       Attributes
        cancelFunc context.CancelFunc
        config     *client.Config
        client     client.Client
        timeout    time.Duration
}

// NewLazyClient creates new LazyClient instances
func NewLazyClient(config *client.Config, attr Attributes, timeout time.Duration) LazyClient <span class="cov4" title="2">{
        return &amp;lazyClient{
                config:  config,
                attr:    attr,
                timeout: timeout,
        }
}</span>

func (lc *lazyClient) init() error <span class="cov10" title="5">{
        if lc.client == nil </span><span class="cov4" title="2">{
                c, err := client.New(*lc.config)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">lc.client = c</span>
        }
        <span class="cov8" title="4">if lc.api == nil </span><span class="cov1" title="1">{
                api := client.NewKeysAPI(lc.client)
                lc.api = api
        }</span>
        <span class="cov8" title="4">return nil</span>
}

func (lc *lazyClient) LazyGet(pattern string) (*string, error) <span class="cov4" title="2">{
        initErr := lc.init()
        if initErr != nil </span><span class="cov0" title="0">{
                return nil, initErr
        }</span>
        <span class="cov4" title="2">key := lc.attr.Format(pattern)
        var originalValue *string
        defer lc.cancel()
        resp, err := lc.api.Get(lc.getContext(), key, nil)
        if err != nil </span><span class="cov1" title="1">{
                if !strings.HasPrefix(err.Error(), "100") </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }<span class="cov1" title="1"> else {
                originalValue = &amp;resp.Node.Value
        }</span>
        <span class="cov4" title="2">return originalValue, nil</span>
}

func (lc *lazyClient) LazySet(pattern, value string) error <span class="cov4" title="2">{
        initErr := lc.init()
        if initErr != nil </span><span class="cov1" title="1">{
                return initErr
        }</span>
        <span class="cov1" title="1">key := lc.attr.Format(pattern)
        originalValue, getErr := lc.LazyGet(pattern)
        if getErr != nil </span><span class="cov0" title="0">{
                return getErr
        }</span>
        <span class="cov1" title="1">if originalValue == nil || value != *originalValue </span><span class="cov1" title="1">{
                defer lc.cancel()
                _, err := lc.api.Set(lc.getContext(), key, value, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (lc *lazyClient) List(pattern string, options *client.GetOptions) ([]*client.Node, error) <span class="cov1" title="1">{
        initErr := lc.init()
        if initErr != nil </span><span class="cov0" title="0">{
                return []*client.Node{}, initErr
        }</span>
        <span class="cov1" title="1">key := lc.attr.Format(pattern)
        defer lc.cancel()
        resp, err := lc.api.Get(lc.getContext(), key, options)
        if err != nil </span><span class="cov0" title="0">{
                return []*client.Node{}, err
        }</span>
        <span class="cov1" title="1">if !resp.Node.Dir </span><span class="cov0" title="0">{
                return []*client.Node{}, errors.New("Path is not directory")
        }</span>
        <span class="cov1" title="1">return resp.Node.Nodes, nil</span>
}

func (lc *lazyClient) getContext() context.Context <span class="cov8" title="4">{
        ctx := context.Background()
        if lc.timeout &gt; 0 </span><span class="cov8" title="4">{
                ctx, lc.cancelFunc = context.WithTimeout(ctx, lc.timeout)
        }</span>
        <span class="cov8" title="4">return ctx</span>
}

func (lc *lazyClient) cancel() <span class="cov8" title="4">{
        if lc.cancelFunc != nil </span><span class="cov8" title="4">{
                lc.cancelFunc()
                lc.cancelFunc = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package rules

import (
        "time"

        "github.com/IBM-Bluemix/go-etcd-lock/lock"
        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/coreos/etcd/clientv3/concurrency"
        "golang.org/x/net/context"
)

type ruleLocker interface {
        lock(string, int) (ruleLock, error)
}

type ruleLock interface {
        unlock()
}

type lockLock struct {
        lockInst lock.Lock
}

func (ll *lockLock) unlock() <span class="cov1" title="1">{
        err := ll.lockInst.Release()
        if err != nil </span><span class="cov0" title="0">{
        }</span>
}

type lockLocker struct {
        locker lock.Locker
}

func (ll *lockLocker) lock(key string, ttl int) (ruleLock, error) <span class="cov1" title="1">{
        lockInst, err := ll.locker.Acquire(key, uint64(ttl))
        return &amp;lockLock{lockInst}, err
}</span>

func newLockLocker(cl client.Client) ruleLocker <span class="cov9" title="11">{
        return &amp;lockLocker{
                locker: lock.NewEtcdLocker(cl, false),
        }
}</span>

func newV3Locker(cl *clientv3.Client) ruleLocker <span class="cov10" title="12">{
        return &amp;v3Locker{
                cl: cl,
        }
}</span>

type v3Locker struct {
        cl *clientv3.Client
}

func (v3l *v3Locker) lock(key string, ttl int) (ruleLock, error) <span class="cov4" title="3">{
        return v3l.lockWithTimeout(key, ttl, 5)
}</span>
func (v3l *v3Locker) lockWithTimeout(key string, ttl int, timeout int) (ruleLock, error) <span class="cov6" title="4">{
        s, err := concurrency.NewSession(v3l.cl, concurrency.WithTTL(ttl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="4">m := concurrency.NewMutex(s, key)
        ctx, _ := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
        err = m.Lock(ctx)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;v3Lock{
                mutex:   m,
                session: s,
        }, nil</span>
}

type v3Lock struct {
        mutex   *concurrency.Mutex
        session *concurrency.Session
}

func (v3l *v3Lock) unlock() <span class="cov3" title="2">{
        ctx, _ := context.WithTimeout(context.Background(), time.Duration(5)*time.Second)
        err := v3l.mutex.Unlock(ctx)
        if err == nil </span><span class="cov3" title="2">{
                v3l.session.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rules

import (
        "regexp"
        "strings"
)

type keyMatcher interface {
        getPrefix() string
        match(string) (keyMatch, bool)
        getPattern() string
        getPrefixesWithConstraints(constraints map[string]constraint) []string
}

type regexKeyMatcher struct {
        regex    *regexp.Regexp
        fieldMap map[string]int
        pattern  string
}

type keyMatch interface {
        GetAttribute(name string) *string
        Format(pattern string) string
}

func (rkm *regexKeyMatcher) getPrefix() string <span class="cov6" title="61">{
        end := strings.Index(rkm.pattern, ":")
        if end == -1 </span><span class="cov5" title="19">{
                end = len(rkm.pattern)
        }</span>
        <span class="cov6" title="61">return rkm.pattern[0:end]</span>
}

func (rkm *regexKeyMatcher) getPrefixesWithConstraints(constraints map[string]constraint) []string <span class="cov4" title="18">{
        out := []string{}
        firstColon := strings.Index(rkm.pattern, ":")
        if firstColon == -1 </span><span class="cov4" title="12">{
                out = append(out, rkm.getPrefix())
        }</span><span class="cov3" title="6"> else {
                end := strings.Index(rkm.pattern[firstColon:], "/")
                if end == -1 </span><span class="cov2" title="3">{
                        end = len(rkm.pattern)
                }</span><span class="cov2" title="3"> else {
                        end = firstColon + end
                }</span>
                <span class="cov3" title="6">attrName := rkm.pattern[firstColon+1 : end]
                constr, ok := constraints[attrName]
                if !ok </span><span class="cov3" title="5">{
                        out = append(out, rkm.getPrefix())
                }</span><span class="cov1" title="1"> else {
                        outPtr := &amp;out
                        buildPrefixesFromConstraint(rkm.pattern[:firstColon]+constr.prefix, 0, constr, outPtr)
                        out = *outPtr
                }</span>
        }
        <span class="cov4" title="18">return out</span>
}

func buildPrefixesFromConstraint(base string, index int, constr constraint, prefixes *[]string) <span class="cov2" title="3">{
        myChars := constr.chars[index]
        if index+1 == len(constr.chars) </span><span class="cov1" title="2">{
                // Last set
                for _, char := range myChars </span><span class="cov2" title="4">{
                        newPrefixes := append(*prefixes, base+string(char))
                        *prefixes = newPrefixes
                }</span>
        }<span class="cov1" title="1"> else {
                for _, char := range myChars </span><span class="cov1" title="2">{
                        newBase := base + string(char)
                        buildPrefixesFromConstraint(newBase, index+1, constr, prefixes)
                }</span>
        }
}

func (rkm *regexKeyMatcher) getPattern() string <span class="cov6" title="44">{
        return rkm.pattern
}</span>

type regexKeyMatch struct {
        matchStrings []string
        fieldMap     map[string]int
}

func newKeyMatch(path string, kmr *regexKeyMatcher) *regexKeyMatch <span class="cov6" title="62">{
        results := kmr.regex.FindStringSubmatch(path)
        if results == nil </span><span class="cov6" title="40">{
                return nil
        }</span>
        <span class="cov5" title="22">km := &amp;regexKeyMatch{
                matchStrings: results,
                fieldMap:     kmr.fieldMap,
        }
        return km</span>
}

func (m *regexKeyMatch) GetAttribute(name string) *string <span class="cov7" title="100">{
        index, ok := m.fieldMap[name]
        if !ok </span><span class="cov1" title="2">{
                return nil
        }</span>
        <span class="cov7" title="98">result := m.matchStrings[index]
        return &amp;result</span>
}

func (m *regexKeyMatch) Format(pattern string) string <span class="cov5" title="23">{
        return formatWithAttributes(pattern, m)
}</span>
func formatWithAttributes(pattern string, m Attributes) string <span class="cov7" title="78">{
        paths := strings.Split(pattern, "/")
        result := ""
        for _, path := range paths </span><span class="cov9" title="417">{
                if len(path) == 0 </span><span class="cov7" title="78">{
                        continue</span>
                }
                <span class="cov9" title="339">result = result + "/"
                if strings.HasPrefix(path, ":") </span><span class="cov7" title="155">{
                        attr := m.GetAttribute(path[1:])
                        if attr == nil </span><span class="cov5" title="27">{
                                s := path
                                attr = &amp;s
                        }</span>
                        <span class="cov7" title="155">result = result + *attr</span>
                }<span class="cov8" title="184"> else {
                        result = result + path
                }</span>
        }
        <span class="cov7" title="78">return result</span>
}

// Keep the bool return value, because it's tricky to check for null
// references when dealing with interfaces
func (rkm *regexKeyMatcher) match(path string) (keyMatch, bool) <span class="cov6" title="62">{
        m := newKeyMatch(path, rkm)
        if m == nil </span><span class="cov6" title="40">{
                return nil, false
        }</span>
        <span class="cov5" title="22">return m, true</span>
}

func newRegexKeyMatcher(pattern string) (*regexKeyMatcher, error) <span class="cov6" title="49">{
        fields, regexString := parsePath(pattern)
        regex, err := regexp.Compile(regexString)
        if err != nil </span><span class="cov2" title="4">{
                return nil, err
        }</span>
        <span class="cov6" title="45">return &amp;regexKeyMatcher{
                regex:    regex,
                fieldMap: fields,
                pattern:  pattern,
        }, nil</span>
}

type mapAttributes struct {
        values map[string]string
}

func (ma *mapAttributes) GetAttribute(key string) *string <span class="cov6" title="53">{
        value, ok := ma.values[key]
        if !ok </span><span class="cov5" title="26">{
                return nil
        }</span>
        <span class="cov5" title="27">return &amp;value</span>
}

func (ma *mapAttributes) Format(path string) string <span class="cov3" title="8">{
        return formatWithAttributes(path, ma)
}</span>

func parsePath(pattern string) (map[string]int, string) <span class="cov7" title="142">{
        paths := strings.Split(pattern, "/")
        regex := ""
        fields := make(map[string]int)
        fieldIndex := 1
        for _, path := range paths </span><span class="cov10" title="682">{
                if len(path) == 0 </span><span class="cov7" title="142">{
                        continue</span>
                }
                <span class="cov9" title="540">regex = regex + "/"
                if strings.HasPrefix(path, ":") </span><span class="cov8" title="188">{
                        regex = regex + "([^\\/:]+)"
                        fields[path[1:]] = fieldIndex
                        fieldIndex++
                }</span><span class="cov9" title="352"> else {
                        regex = regex + path
                }</span>
        }
        <span class="cov7" title="142">return fields, regex</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rules

import (
        "time"

        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "golang.org/x/net/context"
)

const (
        etcdMetricsMetadataKey = "etcdMetricsMetadata"
)

type EtcdMetricsMetadata struct {
        Method   string
        Duration time.Duration
        Error    error
}

func SetMethod(ctx context.Context, method string) context.Context <span class="cov10" title="24">{
        return context.WithValue(ctx, etcdMetricsMetadataKey,
                &amp;EtcdMetricsMetadata{Method: method},
        )
}</span>

func GetMetricsMetadata(ctx context.Context) *EtcdMetricsMetadata <span class="cov2" title="2">{
        out := ctx.Value(etcdMetricsMetadataKey)
        if md, ok := out.(*EtcdMetricsMetadata); ok </span><span class="cov1" title="1">{
                return md
        }</span>
        <span class="cov1" title="1">return nil</span>
}

type WrapKeysAPI func(client.KeysAPI) client.KeysAPI

func defaultWrapKeysAPI(keysAPI client.KeysAPI) client.KeysAPI <span class="cov7" title="9">{
        return keysAPI
}</span>

type WrapKV func(clientv3.KV) clientv3.KV

func defaultWrapKV(kv clientv3.KV) clientv3.KV <span class="cov6" title="7">{
        return kv
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package rules

import (
        "time"

        "golang.org/x/net/context"
)

type ContextProvider func() context.Context

func defaultContextProvider() context.Context <span class="cov3" title="2">{
        c, _ := context.WithTimeout(context.Background(), time.Minute*5)
        return c
}</span>

type engineOptions struct {
        concurrency, crawlerTTL, syncGetTimeout, syncInterval, watchTimeout int
        syncDelay                                                           int
        constraints                                                         map[string]constraint
        contextProvider                                                     ContextProvider
        keyExpansion                                                        map[string][]string
        lockTimeout                                                         int
        crawlMutex                                                          *string
}

func makeEngineOptions(options ...EngineOption) engineOptions <span class="cov10" title="13">{
        opts := engineOptions{
                concurrency:     5,
                constraints:     map[string]constraint{},
                contextProvider: defaultContextProvider,
                syncDelay:       1,
                lockTimeout:     30,
                syncInterval:    300,
                syncGetTimeout:  0,
                watchTimeout:    0,
        }
        for _, opt := range options </span><span class="cov9" title="12">{
                opt.apply(&amp;opts)
        }</span>
        <span class="cov10" title="13">return opts</span>
}

// EngineOption instances control the overall behavior of an Engine
// instance.  Behavior for individual rules can be controlled via
// RuleOption instances.
type EngineOption interface {
        apply(*engineOptions)
}

type engineOptionFunction func(*engineOptions)

func (f engineOptionFunction) apply(o *engineOptions) <span class="cov9" title="12">{
        f(o)
}</span>

// EngineLockTimeout controls the TTL of a lock in seconds.
func EngineLockTimeout(lockTimeout int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.lockTimeout = lockTimeout
        }</span>)
}

// EngineConcurrency controls the number of concurrent workers
// processing rule tasks.
func EngineConcurrency(workers int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.concurrency = workers
        }</span>)
}

// EngineWatchTimeout controls the timeout of a watch operation in seconds.
func EngineWatchTimeout(watchTimeout int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.watchTimeout = watchTimeout
        }</span>)
}

// KeyExpansion enables attributes in rules to be fixed at run time
// while allowing the rule declarations to continue to use the
// attribute placeholders.  For instance, an application may
// use a root directory "/:geo" to hold data for a given geography.
// Passing map[string][]string{"geo":{"na"}} into the KeyExpansion
// option will cause all rules with the "/:geo/" prefix to be rendered
// as "/na/..." but all paths rendered with attributes from realized
// rules will still correctly resolve ":geo" to "na".  This allows
// the placeholder values to be set as application configuration
// settings while minimizing the scope of the watchers.
func KeyExpansion(keyExpansion map[string][]string) EngineOption <span class="cov5" title="4">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov5" title="4">{
                // Combine existing pairings with additional pairings, with
                // collisions resolved by having later values overwrite
                // earlier ones, i.e. "last one wins"
                if o.keyExpansion != nil </span><span class="cov1" title="1">{
                        for k, v := range keyExpansion </span><span class="cov3" title="2">{
                                o.keyExpansion[k] = v
                        }</span>
                        <span class="cov1" title="1">return</span>
                }
                <span class="cov4" title="3">o.keyExpansion = keyExpansion</span>
        })
}

// KeyConstraint enables multiple query prefixes to be generated for a specific
// attribute as a way to limit the scope of a query for a prefix query.
func KeyConstraint(attribute string, prefix string, chars [][]rune) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.constraints[attribute] = constraint{
                        chars:  chars,
                        prefix: prefix,
                }
        }</span>)
}

// EngineSyncInterval enables the interval between sync or crawler runs to be configured.
// The interval is in seconds.
func EngineSyncInterval(interval int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.syncInterval = interval
        }</span>)
}

// EngineSyncDelay enables the throttling of the crawlers by introducing a delay (in ms)
// between queries to keep the crawlers from overwhelming etcd.
func EngineSyncDelay(delay int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.syncDelay = delay
        }</span>)
}

// EngineContextProvider sets a custom provider for generating context instances for use
// by callbacks.
func EngineContextProvider(cp ContextProvider) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.contextProvider = cp
        }</span>)
}

// EngineCrawlMutex sets an application identifier mutex and a TTL value for the mutex
// to limit the number of instances of an application performing a crawl at any given
// time to one.  mutexTTL refers to how long the mutex is in effect; if set too short,
// multiple instances of an application may end up crawling simultaneously.  Note that this
// functionality is only implemented in etcd v3 and that a mutex in etcd v3 is held
// only while the app instance that created it is still active. This means that setting
// a high value, such as 3600 seconds, does not expose one to the risk of no crawls
// occuring for a maximum of one hour if an application instance terminates at the
// beginning of a crawler run.
func EngineCrawlMutex(mutex string, mutexTTL int) EngineOption <span class="cov1" title="1">{
        return engineOptionFunction(func(o *engineOptions) </span><span class="cov1" title="1">{
                o.crawlMutex = &amp;mutex
                o.crawlerTTL = mutexTTL
        }</span>)
}

type ruleOptions struct {
        lockTimeout     int
        contextProvider ContextProvider
}

func makeRuleOptions(options ...RuleOption) ruleOptions <span class="cov9" title="11">{
        opts := ruleOptions{
                lockTimeout: 0,
        }
        for _, opt := range options </span><span class="cov5" title="4">{
                opt.apply(&amp;opts)
        }</span>
        <span class="cov9" title="11">return opts</span>
}

// RuleOption instances control the behavior of individual rules.
type RuleOption interface {
        apply(*ruleOptions)
}

type ruleOptionFunction func(*ruleOptions)

func (f ruleOptionFunction) apply(o *ruleOptions) <span class="cov5" title="4">{
        f(o)
}</span>

// RuleLockTimeout controls the TTL of the locks associated
// with the rule, in seconds.
func RuleLockTimeout(lockTimeout int) RuleOption <span class="cov4" title="3">{
        return ruleOptionFunction(func(o *ruleOptions) </span><span class="cov4" title="3">{
                o.lockTimeout = lockTimeout
        }</span>)
}

// RuleContextProvider sets a custom provider for generating context instances for use
// by a specific callback.
func RuleContextProvider(cp ContextProvider) RuleOption <span class="cov1" title="1">{
        return ruleOptionFunction(func(o *ruleOptions) </span><span class="cov1" title="1">{
                o.contextProvider = cp
        }</span>)
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rules

import (
        "strings"
)

type ruleManager struct {
        constraints       map[string]constraint
        currentIndex      int
        rulesBySlashCount map[int]map[DynamicRule]int
        prefixes          map[string]string
}

func newRuleManager(constraints map[string]constraint) ruleManager <span class="cov6" title="8">{
        rm := ruleManager{
                rulesBySlashCount: map[int]map[DynamicRule]int{},
                prefixes:          map[string]string{},
                constraints:       constraints,
                currentIndex:      0,
        }
        return rm
}</span>

func (rm *ruleManager) getStaticRules(key string, value *string) map[staticRule]int <span class="cov6" title="6">{
        slashCount := strings.Count(key, "/")
        out := make(map[staticRule]int)
        rules, ok := rm.rulesBySlashCount[slashCount]
        if ok </span><span class="cov4" title="3">{
                for rule, index := range rules </span><span class="cov4" title="4">{
                        sRule, _, inScope := rule.makeStaticRule(key, value)
                        if inScope &amp;&amp; sRule.satisfiable(key, value) </span><span class="cov4" title="3">{
                                out[sRule] = index
                        }</span>
                }
        }
        <span class="cov6" title="6">return out</span>
}

func (rm *ruleManager) addRule(rule DynamicRule) int <span class="cov8" title="13">{
        for _, pattern := range rule.getPatterns() </span><span class="cov8" title="17">{
                slashCount := strings.Count(pattern, "/")
                rules, ok := rm.rulesBySlashCount[slashCount]
                if !ok </span><span class="cov7" title="12">{
                        rules = map[DynamicRule]int{}
                        rm.rulesBySlashCount[slashCount] = rules
                }</span>
                <span class="cov8" title="17">rules[rule] = rm.currentIndex</span>
        }
        <span class="cov8" title="13">for _, prefix := range rule.getPrefixesWithConstraints(rm.constraints) </span><span class="cov8" title="17">{
                rm.prefixes[prefix] = ""
        }</span>
        <span class="cov8" title="13">rm.prefixes = reducePrefixes(rm.prefixes)
        lastIndex := rm.currentIndex
        rm.currentIndex = rm.currentIndex + 1
        return lastIndex</span>
}

// Removes any path prefixes that have other path prefixes as
// string prefixes
func reducePrefixes(prefixes map[string]string) map[string]string <span class="cov8" title="14">{
        out := map[string]string{}
        sorted := sortPrefixesByLength(prefixes)
        for _, prefix := range sorted </span><span class="cov9" title="22">{
                add := true
                for addedPrefix := range out </span><span class="cov6" title="8">{
                        if strings.HasPrefix(prefix, addedPrefix) </span><span class="cov2" title="2">{
                                add = false
                        }</span>
                }
                <span class="cov9" title="22">if add </span><span class="cov9" title="20">{
                        out[prefix] = ""
                }</span>
        }
        <span class="cov8" title="14">return out</span>
}

// Sorts prefixes shortest to longest
func sortPrefixesByLength(prefixes map[string]string) []string <span class="cov8" title="15">{
        out := []string{}
        for prefix := range prefixes </span><span class="cov10" title="25">{
                out = append(out, prefix)
        }</span>
        <span class="cov8" title="15">for i := 1; i &lt; len(out); i++ </span><span class="cov7" title="10">{
                x := out[i]
                j := i - 1
                for j &gt;= 0 &amp;&amp; len(out[j]) &gt; len(x) </span><span class="cov5" title="5">{
                        out[j+1] = out[j]
                        j = j - 1
                }</span>
                <span class="cov7" title="10">out[j+1] = x</span>
        }
        <span class="cov8" title="15">return out</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package rules

type ruleFactory interface {
        // The actual keys derived from patterns
        newRule(keys []string, attr Attributes) staticRule
}

type staticRule interface {
        keyMatch(key string) bool
        satisfiable(key string, value *string) bool
        satisfied(api readAPI) (bool, error)
        getAttributes() Attributes
}

type readAPI interface {
        get(string) (*string, error)
}

type baseRule struct {
        attr Attributes
}

func (br *baseRule) getAttributes() Attributes <span class="cov4" title="5">{
        return br.attr
}</span>

type equalsLiteralRule struct {
        baseRule
        key   string
        value *string
}

type equalsLiteralRuleFactory struct {
        value *string
}

func newEqualsLiteralRuleFactory(value *string) ruleFactory <span class="cov8" title="27">{
        factory := equalsLiteralRuleFactory{
                value: value,
        }
        return &amp;factory
}</span>

func (elrf *equalsLiteralRuleFactory) newRule(keys []string, attr Attributes) staticRule <span class="cov10" title="45">{
        br := baseRule{
                attr: attr,
        }
        r := equalsLiteralRule{
                baseRule: br,
                key:      keys[0],
                value:    elrf.value,
        }
        return &amp;r
}</span>

func (elr *equalsLiteralRule) satisfiable(key string, value *string) bool <span class="cov8" title="21">{
        return key == elr.key
}</span>

func (elr *equalsLiteralRule) satisfied(api readAPI) (bool, error) <span class="cov7" title="17">{
        value, err := api.get(elr.key)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>
        <span class="cov7" title="16">if value == nil </span><span class="cov3" title="3">{
                return elr.value == nil, nil
        }</span>
        <span class="cov7" title="13">if elr.value == nil </span><span class="cov4" title="5">{
                return false, nil
        }</span>
        <span class="cov5" title="8">return *value == *elr.value, nil</span>
}

func (elr *equalsLiteralRule) keyMatch(key string) bool <span class="cov2" title="2">{
        return elr.key == key
}</span>

type compoundStaticRule struct {
        nestedRules []staticRule
}

func (csr *compoundStaticRule) getAttributes() Attributes <span class="cov2" title="2">{
        return csr.nestedRules[0].getAttributes()
}</span>

func (csr *compoundStaticRule) satisfiable(key string, value *string) bool <span class="cov2" title="2">{
        anySatisfiable := false
        for _, rule := range csr.nestedRules </span><span class="cov3" title="3">{
                if rule.satisfiable(key, value) </span><span class="cov1" title="1">{
                        anySatisfiable = true
                        break</span>
                }
        }
        <span class="cov2" title="2">return anySatisfiable</span>
}

func (csr *compoundStaticRule) keyMatch(key string) bool <span class="cov3" title="3">{
        for _, rule := range csr.nestedRules </span><span class="cov4" title="5">{
                if rule.keyMatch(key) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

type andStaticRule struct {
        compoundStaticRule
}

func (asr *andStaticRule) satisfied(api readAPI) (bool, error) <span class="cov5" title="7">{
        for _, rule := range asr.nestedRules </span><span class="cov6" title="12">{
                satisfied, err := rule.satisfied(api)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov6" title="11">if !satisfied </span><span class="cov3" title="3">{
                        return false, nil
                }</span>
        }
        <span class="cov3" title="3">return true, nil</span>
}

type orStaticRule struct {
        compoundStaticRule
}

func (osr *orStaticRule) satisfied(api readAPI) (bool, error) <span class="cov5" title="6">{
        for _, rule := range osr.nestedRules </span><span class="cov5" title="6">{
                satisfied, err := rule.satisfied(api)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov4" title="5">if satisfied </span><span class="cov4" title="4">{
                        return true, nil
                }</span>
        }
        <span class="cov1" title="1">return false, nil</span>
}

type notStaticRule struct {
        nested staticRule
}

func (nsr *notStaticRule) getAttributes() Attributes <span class="cov1" title="1">{
        return nsr.nested.getAttributes()
}</span>

func (nsr *notStaticRule) keyMatch(key string) bool <span class="cov2" title="2">{
        return nsr.nested.keyMatch(key)
}</span>

func (nsr *notStaticRule) satisfiable(key string, value *string) bool <span class="cov4" title="5">{
        return nsr.nested.keyMatch(key)
}</span>

func (nsr *notStaticRule) satisfied(api readAPI) (bool, error) <span class="cov6" title="10">{
        satisfied, err := nsr.nested.satisfied(api)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>
        <span class="cov6" title="9">return !satisfied, nil</span>
}

type equalsRule struct {
        baseRule
        keys []string
}

func (er *equalsRule) satisfiable(key string, value *string) bool <span class="cov4" title="5">{
        return er.keyMatch(key)
}</span>

func (er *equalsRule) keyMatch(key string) bool <span class="cov5" title="7">{
        if len(er.keys) == 0 </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov5" title="6">for _, ruleKey := range er.keys </span><span class="cov6" title="10">{
                if key == ruleKey </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

func (er *equalsRule) satisfied(api readAPI) (bool, error) <span class="cov7" title="14">{
        if len(er.keys) == 0 </span><span class="cov1" title="1">{
                return true, nil
        }</span>
        <span class="cov7" title="13">ref, err1 := api.get(er.keys[0])
        // Failed to get reference value?
        if err1 != nil </span><span class="cov1" title="1">{
                return false, err1
        }</span>
        <span class="cov6" title="12">for index, key := range er.keys </span><span class="cov8" title="24">{
                if index == 0 </span><span class="cov6" title="12">{
                        continue</span>
                }
                // Failed to get next value?
                <span class="cov6" title="12">value, err2 := api.get(key)
                if err2 != nil </span><span class="cov1" title="1">{
                        return false, err2
                }</span>
                // Value is nil
                <span class="cov6" title="11">if value == nil </span><span class="cov5" title="6">{
                        // Reference value isn't
                        if ref != nil </span><span class="cov3" title="3">{
                                return false, nil
                        }</span>
                }<span class="cov4" title="5"> else {
                        // Value is not nil but reference is
                        if ref == nil </span><span class="cov1" title="1">{
                                return false, nil
                        }</span>
                        // Neither is nil
                        <span class="cov4" title="4">if *ref != *value </span><span class="cov2" title="2">{
                                return false, nil
                        }</span>
                }
        }
        <span class="cov4" title="5">return true, nil</span>
}

type equalsRuleFactory struct{}

func (erf *equalsRuleFactory) newRule(keys []string, attr Attributes) staticRule <span class="cov1" title="1">{
        br := baseRule{
                attr: attr,
        }
        er := equalsRule{
                baseRule: br,
                keys:     keys,
        }
        return &amp;er
}</span>

func newEqualsRuleFactory() ruleFactory <span class="cov1" title="1">{
        erf := equalsRuleFactory{}
        return &amp;erf
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package rules

import (
        "strings"
        "time"

        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
)

func newWatcher(config client.Config, prefix string, logger zap.Logger, proc keyProc, watchTimeout int, wrapKeysAPI WrapKeysAPI) (watcher, error) <span class="cov1" title="4">{
        ec, err := client.New(config)
        if err != nil </span><span class="cov0" title="0">{
                return watcher{}, err
        }</span>
        <span class="cov1" title="4">ea := wrapKeysAPI(client.NewKeysAPI(ec))
        api := etcdReadAPI{
                baseReadAPI: baseReadAPI{},
                keysAPI:     ea,
        }
        ew := newEtcdKeyWatcher(ea, prefix, time.Duration(watchTimeout)*time.Second)
        return watcher{
                api:    &amp;api,
                kw:     ew,
                kp:     proc,
                logger: logger,
        }, nil</span>
}

func newV3Watcher(config clientv3.Config, prefix string, logger zap.Logger, proc keyProc, watchTimeout int, kvWrapper WrapKV) (watcher, error) <span class="cov1" title="4">{
        ec, err := clientv3.New(config)
        if err != nil </span><span class="cov0" title="0">{
                return watcher{}, err
        }</span>
        <span class="cov1" title="4">api := etcdV3ReadAPI{
                baseReadAPI: baseReadAPI{},
                kV:          kvWrapper(clientv3.NewKV(ec)),
        }
        ew := newEtcdV3KeyWatcher(ec, prefix, time.Duration(watchTimeout)*time.Second)
        return watcher{
                api:    &amp;api,
                kw:     ew,
                kp:     proc,
                logger: logger,
        }, nil</span>
}

type watcher struct {
        api      readAPI
        kw       keyWatcher
        kp       keyProc
        logger   zap.Logger
        stopping uint32
        stopped  uint32
}

func (w *watcher) run() <span class="cov2" title="8">{
        atomicSet(&amp;w.stopped, false)
        for !is(&amp;w.stopping) </span><span class="cov2" title="8">{
                w.singleRun()
        }</span>
        <span class="cov1" title="4">atomicSet(&amp;w.stopped, true)</span>
}

func (w *watcher) stop() <span class="cov1" title="4">{
        atomicSet(&amp;w.stopping, true)
        w.kw.cancel()
}</span>

func (w *watcher) isStopped() bool <span class="cov10" title="1578617">{
        return is(&amp;w.stopped)
}</span>

func (w *watcher) singleRun() <span class="cov2" title="10">{
        key, value, err := w.kw.next()
        if err != nil </span><span class="cov1" title="3">{
                w.logger.Error("Watcher error", zap.Error(err))
                if strings.Contains(err.Error(), "connection refused") </span><span class="cov0" title="0">{
                        w.logger.Info("Cluster unavailable; waiting one minute to retry")
                        time.Sleep(time.Minute)
                }</span><span class="cov1" title="3"> else {
                        // Maximum logging rate is 1 per second.
                        time.Sleep(time.Second)
                }</span>
                <span class="cov1" title="3">return</span>
        }
        <span class="cov1" title="3">w.kp.processKey(key, value, w.api, w.logger, map[string]string{})</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rules

import (
        "github.com/coreos/etcd/client"
        "github.com/coreos/etcd/clientv3"
        "github.com/uber-go/zap"
)

type baseWorker struct {
        locker   ruleLocker
        api      readAPI
        workerID string
        stopping uint32
        stopped  uint32
}

type worker struct {
        baseWorker
        engine *engine
}

type v3Worker struct {
        baseWorker
        engine *v3Engine
}

func newWorker(workerID string, engine *engine) (worker, error) <span class="cov6" title="10">{
        var api readAPI
        var locker ruleLocker
        c, err := client.New(engine.config)
        if err != nil </span><span class="cov0" title="0">{
                return worker{}, err
        }</span>
        <span class="cov6" title="10">locker = newLockLocker(c)
        api = &amp;etcdReadAPI{
                keysAPI: client.NewKeysAPI(c),
        }
        w := worker{
                baseWorker: baseWorker{
                        api:      api,
                        locker:   locker,
                        workerID: workerID,
                },
                engine: engine,
        }
        return w, nil</span>
}

func newV3Worker(workerID string, engine *v3Engine) (v3Worker, error) <span class="cov6" title="10">{
        var api readAPI
        var locker ruleLocker

        c, err := clientv3.New(engine.configV3)
        if err != nil </span><span class="cov0" title="0">{
                return v3Worker{}, err
        }</span>
        <span class="cov6" title="10">locker = newV3Locker(c)
        api = &amp;etcdV3ReadAPI{
                kV: c,
        }
        w := v3Worker{
                baseWorker: baseWorker{
                        api:      api,
                        locker:   locker,
                        workerID: workerID,
                },
                engine: engine,
        }
        return w, nil</span>
}

func (w *worker) run() <span class="cov6" title="10">{
        atomicSet(&amp;w.stopped, false)
        for !is(&amp;w.stopping) </span><span class="cov6" title="10">{
                w.singleRun()
        }</span>
        <span class="cov4" title="5">atomicSet(&amp;w.stopped, true)</span>
}

func (w *v3Worker) run() <span class="cov6" title="10">{
        atomicSet(&amp;w.stopped, false)
        for !is(&amp;w.stopping) </span><span class="cov6" title="10">{
                w.singleRun()
        }</span>
        <span class="cov4" title="5">atomicSet(&amp;w.stopped, true)</span>
}

type workCallback func()

func (bw *baseWorker) stop() <span class="cov8" title="20">{
        atomicSet(&amp;bw.stopping, true)
}</span>

func (bw *baseWorker) isStopped() bool <span class="cov10" title="42">{
        return is(&amp;bw.stopped)
}</span>

func (bw *baseWorker) doWork(loggerPtr *zap.Logger,
        rulePtr *staticRule, lockTTL int, callback workCallback,
        lockKey string) <span class="cov3" title="3">{
        logger := *loggerPtr
        rule := *rulePtr
        sat, err1 := rule.satisfied(bw.api)
        if err1 != nil </span><span class="cov0" title="0">{
                logger.Error("Error checking rule", zap.Error(err1))
                return
        }</span>
        <span class="cov3" title="3">if !sat || is(&amp;bw.stopping) </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">l, err2 := bw.locker.lock(lockKey, lockTTL)
        if err2 != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to acquire lock", zap.String("lock_key", lockKey), zap.Error(err2))
                return
        }</span>
        <span class="cov1" title="1">defer l.unlock()
        // Check for a second time, since checking and locking
        // are not atomic.
        sat, err1 = rule.satisfied(bw.api)
        if err1 != nil </span><span class="cov0" title="0">{
                logger.Error("Error checking rule", zap.Error(err1))
                return
        }</span>
        <span class="cov1" title="1">if sat &amp;&amp; !is(&amp;bw.stopping) </span><span class="cov1" title="1">{
                callback()
        }</span>
}

func (bw *baseWorker) addWorkerID(ruleContext map[string]string) <span class="cov3" title="3">{
        ruleContext["rule_worker"] = bw.workerID
}</span>

func (w *worker) singleRun() <span class="cov7" title="13">{
        work := &lt;-w.engine.workChannel
        task := work.ruleTask
        if is(&amp;w.stopping) </span><span class="cov4" title="5">{
                return
        }</span>
        <span class="cov3" title="3">w.addWorkerID(task.Metadata)
        task.Logger = task.Logger.With(zap.String("worker", w.workerID))
        w.doWork(&amp;task.Logger, &amp;work.rule, w.engine.getLockTTLForRule(work.ruleIndex), func() </span><span class="cov1" title="1">{ work.ruleTaskCallback(&amp;task) }</span>, work.lockKey)
}

func (w *v3Worker) singleRun() <span class="cov6" title="10">{
        work := &lt;-w.engine.workChannel
        task := work.ruleTask
        if is(&amp;w.stopping) </span><span class="cov4" title="5">{
                return
        }</span>
        <span class="cov0" title="0">w.addWorkerID(task.Metadata)
        task.Logger = task.Logger.With(zap.String("worker", w.workerID))
        w.doWork(&amp;task.Logger, &amp;work.rule, w.engine.getLockTTLForRule(work.ruleIndex), func() </span><span class="cov0" title="0">{ work.ruleTaskCallback(&amp;task) }</span>, work.lockKey)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
